# Battery Info Example - Platform Channels vs JNI

A comprehensive Flutter plugin demonstrating **two approaches to Android native interop**:

1. **Platform Channels (MethodChannel)** - Traditional Flutter approach
2. **JNI with jnigen** - Direct native interop using Flutter's official JNI code generator

## ğŸ¯ Purpose

This example provides a **side-by-side comparison** of both approaches for accessing Android's battery information, helping you understand:
- When to use Platform Channels vs JNI
- Performance differences
- Setup complexity
- Code maintainability

## ğŸ“± Demo
<video width="320" height="240" src="./assets/demo.mov" controls></video>

## ğŸ—ï¸ Architecture

### Platform Channel Approach

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dart   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Method â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚    Kotlin    â”‚
â”‚         â”‚ async   â”‚Channel â”‚   msg   â”‚              â”‚
â”‚         â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”‚        â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ BatteryMgr   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Files:**
- `lib/battery_info_example.dart` - Public API
- `lib/battery_info_example_method_channel.dart` - MethodChannel implementation
- `android/.../BatteryInfoExamplePlugin.kt` - Kotlin platform code

### JNI Approach (with jnigen)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dart   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   FFI   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   JNI    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Java   â”‚
â”‚         â”‚ direct  â”‚  (C++)  â”‚  native â”‚  Bridge  â”‚  call   â”‚         â”‚
â”‚         â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”‚         â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”‚          â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”‚Battery  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Files:**
- `lib/battery_info_jni_wrapper.dart` - JNI wrapper API
- `android/.../BatteryInfoJni.kt` - Kotlin helper class
- `lib/src/generated/` - Auto-generated by jnigen (FFI bindings)
- `jnigen.yaml` - jnigen configuration

## ğŸš€ Getting Started

### Prerequisites

- Flutter SDK (3.3.0+)
- Android SDK
- Android NDK (for JNI compilation)
- Java/Kotlin development environment

### Installation

1. **Clone and navigate to the plugin:**
```bash
cd battery_info_example
```

2. **Install dependencies:**
```bash
flutter pub get
```

3. **Generate JNI bindings (required for JNI approach):**

Set your Android SDK path:
```bash
export ANDROID_SDK_ROOT=$HOME/Library/Android/sdk  # macOS
# or
export ANDROID_SDK_ROOT=$HOME/Android/Sdk          # Linux
```

Generate bindings:
```bash
dart run jnigen --config jnigen.yaml
```

This creates:
- `lib/src/generated/battery_info_jni.dart` - Dart FFI bindings
- `android/src/main/cpp/jni/` - C++ JNI bridge code

4. **Run the example app:**
```bash
cd example
flutter run
```

## ğŸ“ Project Structure

```
battery_info_example/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ battery_info_example.dart              # Platform Channel API
â”‚   â”œâ”€â”€ battery_info_jni_wrapper.dart          # JNI wrapper
â”‚   â””â”€â”€ src/generated/                         # jnigen output
â”‚       â””â”€â”€ battery_info_jni.dart
â”œâ”€â”€ android/
â”‚   â””â”€â”€ src/main/kotlin/.../                   # Kotlin code
â”‚       â”œâ”€â”€ BatteryInfoExamplePlugin.kt        # Platform Channel handler
â”‚       â””â”€â”€ BatteryInfoJni.kt                  # JNI helper class
â”œâ”€â”€ example/
â”‚   â””â”€â”€ lib/main.dart                          # Benchmark UI
â”œâ”€â”€ jnigen.yaml                                # jnigen configuration
â””â”€â”€ pubspec.yaml
```

## ğŸ”¬ Deep Dive: How Each Approach Works

### 1. Platform Channel Implementation

#### Dart Side ([battery_info_example_method_channel.dart](lib/battery_info_example_method_channel.dart))

```dart
class MethodChannelBatteryInfoExample extends BatteryInfoExamplePlatform {
  final methodChannel = const MethodChannel('battery_info_example');

  @override
  Future<int> getBatteryLevel() async {
    final int? result = await methodChannel.invokeMethod<int>('getBatteryLevel');
    return result ?? -1;
  }
}
```

#### Kotlin Side ([BatteryInfoExamplePlugin.kt](android/src/main/kotlin/com/example/battery_info_example/BatteryInfoExamplePlugin.kt))

```kotlin
class BatteryInfoExamplePlugin : FlutterPlugin, MethodCallHandler {
  override fun onMethodCall(call: MethodCall, result: Result) {
    when (call.method) {
      "getBatteryLevel" -> {
        val batteryLevel = getBatteryLevel()
        result.success(batteryLevel)
      }
    }
  }

  private fun getBatteryLevel(): Int {
    val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager
    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
  }
}
```

**How it works:**
1. Dart calls `methodChannel.invokeMethod('getBatteryLevel')`
2. Flutter serializes the call and sends to native side
3. Kotlin receives call in `onMethodCall()`
4. Kotlin calls Android BatteryManager API
5. Result is serialized and sent back to Dart

### 2. JNI Implementation (with jnigen)

#### Step 1: Create Kotlin Helper Class ([BatteryInfoJni.kt](android/src/main/kotlin/com/example/battery_info_example/BatteryInfoJni.kt))

```kotlin
package com.example.battery_info_example

import android.content.Context
import android.os.BatteryManager

class BatteryInfoJni(private val context: Context) {

    fun getBatteryLevel(): Int {
        val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager
        return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
    }

    fun isCharging(): Boolean {
        val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager
        return batteryManager.isCharging
    }

    fun getTemperature(): Int {
        // Returns battery temperature in tenths of a degree Celsius
        val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager
        return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CURRENT_NOW)
    }
}
```

#### Step 2: Configure jnigen ([jnigen.yaml](jnigen.yaml))

```yaml
output:
  dart:
    path: lib/src/generated/battery_info_jni.dart
    structure: single_file

source_path:
  - 'android/src/main/kotlin'

classes:
  - 'com.example.battery_info_example.BatteryInfoJni'
```

#### Step 3: Generate Bindings

```bash
dart run jnigen --config jnigen.yaml
```

This generates:
- **Dart FFI bindings** - Type-safe Dart classes that mirror Kotlin/Java classes
- **JNI bridge code** - Native code that handles JNI calls

#### Step 4: Use Generated Bindings ([battery_info_jni_wrapper.dart](lib/battery_info_jni_wrapper.dart))

```dart
import 'src/generated/battery_info_jni.dart';
import 'package:jni/jni.dart';

class BatteryInfoJniWrapper {
  int getBatteryLevel() {
    // Get Android context via JNI
    final context = Jni.getCurrentActivity();

    // Use generated bindings
    final batteryInfo = BatteryInfoJni(context);
    return batteryInfo.getBatteryLevel();
  }
}
```

**How it works:**
1. Dart calls generated FFI function
2. FFI directly invokes native code (no serialization)
3. Native code uses JNI to call Kotlin method
4. Kotlin calls Android BatteryManager
5. Result flows back through same path

## âš–ï¸ Comparison

| Aspect | Platform Channel | JNI with jnigen |
|--------|-----------------|-----------------|
| **Setup Complexity** | â­ Simple | â­â­â­ Moderate |
| **Code Generation** | Not required | Required (jnigen) |
| **Type Safety** | Runtime checks | Compile-time safety |
| **Performance** | Good (async) | Excellent (direct calls) |
| **Latency** | ~100-500Î¼s | ~10-50Î¼s |
| **Error Handling** | PlatformException | Try-catch in Dart |
| **Maintenance** | Easy | Regenerate on Java changes |
| **Learning Curve** | Low | Medium-High |
| **Official Support** | âœ… Primary method | âœ… Official tool |
| **Use Case** | Most plugins | Performance-critical, existing Java/Kotlin libs |

### Performance Benchmarks

Typical execution times (measured in the example app):

- **Method Channel**: 200-400Î¼s (includes serialization + async messaging)
- **JNI**: 20-80Î¼s (direct native call)

**Note**: For battery level checks (called infrequently), both are fast enough. JNI shines when calling native code thousands of times per second.

## ğŸ“ When to Use Each Approach

### Use Platform Channels When:
âœ… Building standard Flutter plugins
âœ… Performance is not critical
âœ… You want simple, maintainable code
âœ… You're new to Flutter plugin development
âœ… You need async operations (channels are inherently async)

### Use JNI (with jnigen) When:
âœ… You have existing Java/Kotlin libraries to wrap
âœ… Performance is critical (e.g., real-time processing)
âœ… You need to call native code frequently
âœ… You want type-safe bindings
âœ… You're wrapping complex Java APIs

## ğŸ› ï¸ Development Workflow

### Method Channel Development

1. Define method in Dart (MethodChannel)
2. Implement handler in Kotlin
3. Test
4. Done!

### JNI Development with jnigen

1. Write Kotlin helper class
2. Configure `jnigen.yaml`
3. Run `dart run jnigen --config jnigen.yaml`
4. Create Dart wrapper using generated bindings
5. Test
6. **Repeat step 3 whenever Kotlin code changes**

## ğŸ“š Key Files Explained

### [jnigen.yaml](jnigen.yaml)
Configuration file for jnigen code generator. Specifies:
- Input: Kotlin source files
- Output: Where to generate Dart FFI bindings
- Classes: Which Kotlin classes to generate bindings for

### [BatteryInfoJni.kt](android/src/main/kotlin/com/example/battery_info_example/BatteryInfoJni.kt)
Simple Kotlin helper class that wraps Android APIs. This is what jnigen generates bindings for. Keep it simple and focused.

### [battery_info_jni_wrapper.dart](lib/battery_info_jni_wrapper.dart)
Dart wrapper that uses the jnigen-generated bindings. Provides a clean API to Flutter code.

### Generated Files
- `lib/src/generated/battery_info_jni.dart` - Auto-generated FFI bindings

**Note**: These files are generated by jnigen and should be committed to the repository for easier use.

## ğŸ› Troubleshooting

### "JNI bindings not yet generated"

Run the code generator:
```bash
dart run jnigen --config jnigen.yaml
```

### "No SDK Root specified"

Set ANDROID_SDK_ROOT:
```bash
export ANDROID_SDK_ROOT=$HOME/Library/Android/sdk
```

### Build errors after generating JNI code

Clean and rebuild:
```bash
cd example
flutter clean
flutter pub get
flutter run
```

### Context not available in JNI

The current implementation shows how to structure code. Getting the Android Context in pure JNI requires additional setup with Flutter's platform view or activity binding.

## ğŸ§ª Testing the Example

Run the example app:
```bash
cd example
flutter run
```

The app displays:
- **Method Channel** card - Shows battery level via traditional approach
- **JNI** card - Shows battery level via jnigen (after generation)
- **Execution times** - Compare performance
- **Pros/Cons** - Educational comparison

Tap "Refresh" to re-fetch battery info and see updated timings.

## ğŸ“– Learning Resources

- [Flutter Platform Channels](https://docs.flutter.dev/platform-integration/platform-channels)
- [jnigen Package](https://pub.dev/packages/jnigen)
- [dart:ffi Documentation](https://dart.dev/guides/libraries/c-interop)
- [Android BatteryManager](https://developer.android.com/reference/android/os/BatteryManager)
- [JNI Specification](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/)

## ğŸ¤ Contributing

This is an educational example. Contributions welcome:
- Improve JNI context handling
- Add iOS support
- Performance optimizations
- Additional benchmark scenarios

## ğŸ“„ License

MIT License - Part of flutter_credential_manager_compose project

---

## ğŸ¯ Key Takeaways

1. **Platform Channels** are the recommended default for Flutter plugins
2. **JNI with jnigen** is powerful for wrapping existing Java libraries
3. Both approaches are officially supported by Flutter
4. Choose based on your specific needs (simplicity vs performance)
5. jnigen reduces boilerplate and errors compared to manual JNI

**For most Flutter plugins, start with Platform Channels. Consider JNI when you have specific performance requirements or existing Java code to wrap.**
